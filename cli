#!/usr/bin/env bash
# pgdeploy: generate migration from two states for a given schema.
#
# workflow:
#  create new db
#  load target state object definitions
#  rename target schema to TARGET
#  load source state object definitions
#  run reconsile_schema for SOURCE and TARGET

# NOTE: un/qualified objects; references must exist in source for them to be valid in target
# NOTE: consider pipeline as superset of reconsile_schema -> store result *somewhere*

cd ~/git/pg-deploy/

echo "
===============================================================================

 ███████    ████████  ███████   ████████ ███████  ██         ███████   ██    ██
░██░░░░██  ██░░░░░░██░██░░░░██ ░██░░░░░ ░██░░░░██░██        ██░░░░░██ ░░██  ██
░██   ░██ ██      ░░ ░██    ░██░██      ░██   ░██░██       ██     ░░██ ░░████
░███████ ░██         ░██    ░██░███████ ░███████ ░██      ░██      ░██  ░░██
░██░░░░  ░██    █████░██    ░██░██░░░░  ░██░░░░  ░██      ░██      ░██   ░██
░██      ░░██  ░░░░██░██    ██ ░██      ░██      ░██      ░░██     ██    ░██
░██       ░░████████ ░███████  ░████████░██      ░████████ ░░███████     ░██
░░         ░░░░░░░░  ░░░░░░░   ░░░░░░░░ ░░       ░░░░░░░░   ░░░░░░░      ░░

===============================================================================

  VARS: $@
  PWD : $(pwd)
  TIME: $(date)
"


collect_schema() {
    # loop for  sql files that contain $1/pattern        in this dir/$2
    # (awk)    get the filepath      burp f contents to stdout
    for f in $(grep -R "$1\." -c --include=*.sql $2 \
        | awk -F '[,:]' '{print $1}'); do echo "-- $f" && cat $f; done

    # rename inplace for live runs, loading only target/$4 definitions
    # [ -z $4 ] && cat $3 | sed "s/$1\./$4\./g" > $3
}


SEARCH_DIR='./test/schema/'
SOURCE_SCHEMA='staying_alive'
TARGET_SCHEMA='testp'
TARGET_OUTPUT=/tmp/pgdeploy-target-sql && rm -rf $TARGET_OUTPUT
SOURCE_OUTPUT=/tmp/pgdeploy-source-sql && rm -rf $SOURCE_OUTPUT


# CHECK INSTALLED:
#   TODO check this works
# psql -c "select 1 from pg_extension where extname = 'pgdeploy'" \
#     | grep '0 rows' &>/dev/null && echo "ERROR: pgdeploy must be installed!!!" && exit 1

# CREATE TESTDB:
TESTDB='pgd_test'
sql="psql -d $TESTDB"
psql -c "DROP DATABASE $TESTDB" | grep -i error && echo "ERROR: Failure dropping $TESTDB" && exit 1
psql -c "CREATE DATABASE $TESTDB" | grep -i error && echo "ERROR: Failure creating $TESTDB" && exit 1

# CREATE PGDEPLOY FOR `TESTDB':
$sql -c 'create extension pgdeploy' | grep -i error && echo "ERROR: Failure creating extension" && exit 1

# GET TARGET STATE:
collect_schema $SOURCE_SCHEMA "$SEARCH_DIR/new/" > $TARGET_OUTPUT

# LOAD TARGET STATE:
$sql -f $TARGET_OUTPUT

# RENAME TARGET DEFS TO `TARGET_SCHEMA':
$sql -c "alter schema $SOURCE_SCHEMA rename to $TARGET_SCHEMA"


# GET SOURCE STATE:
collect_schema $SOURCE_SCHEMA "$SEARCH_DIR/old/" > $SOURCE_OUTPUT

# LOAD SOURCE STATE:
$sql -f $SOURCE_OUTPUT


# RECONSILE:
$sql -t -c "select ddl from pgdeploy.reconcile_schema('$SOURCE_SCHEMA'::name, '$TARGET_SCHEMA'::name)" \
     -o run-me.sql

echo  "

======
DEBUG:
======

TESTDB:        $TESTDB
SQL CMD:       $sql

SOURCE_SCHEMA: $SOURCE_SCHEMA
TARGET_SCHEMA: $TARGET_SCHEMA

SOURCE_OUTPUT: $SOURCE_OUTPUT ->

$(cat $SOURCE_OUTPUT)

<-

TARGET_OUTPUT: $TARGET_OUTPUT ->

$(cat $TARGET_OUTPUT)

<-

OUTPUT SCRIPT: ./run-me.sql ->

$(cat ./run-me.sql)

<-"
